# Project-1
NN-descent algorithm in C

# Ηλίας Κωνσταντινίδης 1115202000109

# Κωνσταντίνος Μυρτολλάρι

# Αγγελούκος Γκουνέλας


Μεταγλώττιση των πηγαίνων ή/και εκτέλεση των tests γίνεται στον φάκελο Tests με τους εξής τρόπους:
-make
-make run
-make clean
-make valgrind

Το main.c σε αυτό το παραδοτέο δεν χρησιμοποιείται με κάποιον τρόπο. Ο φάκελος Include περιέχει τα header files και ο φάκελος Tests τα πηγαία αρχεία των tests. Οι υπόλοιποι φάκελοι πηγαία που υλοποιούν διάφορες δομές και συναρτήσεις χρήσιμες για την εργασία.

# Dataset

Το dataset περιγράφεται από ένα πλήθος αντικειμένων και διαστέσεων που είναι ίσες με το πλήθος των χαρακτηριστικών(features) του κάθε αντικειμένου. Τα χαρακτηριστικά είναι δείκτες σε δεδομένα και αρχικοποιούνται με NULL. Υπεύθυνος για την φόρτωση του dataset είναι ο χρήστης της βιβλιοθήκης. Η βιβλιοθήκη παρέχει την δυνατότητα για δεικτοδότηση και ενημέρωση των χαρακτηριστικών στα αντικείμενα του dataset. Η μετρική δημιουργείται επίσης από τον χρήστη της βιβλιοθήκης και πρέπει να λειτουργεί  σωστά, δεδομένου ότι αυτή δέχεται ως παράμετρους δείκτες γενικής χρήσης(να χρησιμοποιηθεί κατάλληλο casting). Η βιβλιοθήκη τέλος δεν είναι υπεύθυνη για την αποδέσμευση της μνήμης των χαρακτηριστικών. 

# NNG initialization

Τυχαία αρχικοποίηση του γράφου αναθέτοντας K τυχαίους γείτονες για κάθε αντικείμενο.

# Brute force

Η συνάρτηση brute force υπολογίζει την λύση του προβλήματος K-NN γράφου με την μέθοδο brute force και την αποθηκεύει σε έναν δυσδιάστατο πίνακα NxK.

# NN-Descent

Δημιουργήσαμε δύο υλοποιήσεις του αλγορίθμου NN-Descent: την κλασσική υλοποίηση και την υλοποίηση με το local join. Η μόνη επιπλέον βελτιστοποίηση για την δεύτερη υλοποίηση αφορά την χρήση ενός AVL δέντρου για κάθε αντικείμενο που αποθηκεύει τα αντικείμενα με τα οποία έχει συγκριθεί στο παρελθόν ώστε να αποφεύγεται ο επαναϋπολογισμός της μετρικης για κάθε ζεύγος. Με λίγα λόγια, κάθε ζεύγος συγκρίνεται το πολύ μια φορά. Η εύρεση των γειτόνων των αντικειμένων σε κάθε επανάληψη γίνεται με την ένωση των απευθείας γειτόνων(που βρίσκονται στο heap) και των αντιστρόφων γειτόνων(που βρίσκονται σε ένα ξεχωριστό AVL δέντρο), αποθηκεύοντας την σε μια λίστα. Έπειτα, γίνεται η σύγκριση όλων των γειτόνων του αντικειμένου μεταξύ τούς, ανάλογα με το αν αυτοί βρίσκονται στα AVL δέντρα του γείτονα με τον οποίο πρόκειται να συγκριθούν. Αν σε μια επιλογή δύο γειτόνων, οι γείτονες αυτοί βρίσκονται ο ένας στο AVL δέντρο του άλλου, τότε ο υπολογισμός της απόστασης αποφεύγεται και ο αλγόριθμος συνεχίζει.

Για την αποθήκευση των K κοντινότερων γειτόνων καθώς ο αλγόριθμος εκτελείται γίνεται χρήση ενός max heap μεγίστου μεγέθους K. Σε κάθε ενημέρωση του heap, γίνεται και ταυτόχρονη ενημέρωση του AVL δέντρου που βρίσκονται οι αντίστροφοι γείτονες του αντικειμένου. Επίσης, υπολογίζεται το scan-rate του αλγορίθμου σύμφωνα με το paper. Τέλος, η συνάρτηση επιστρέφει έναν δυσδιάστατο πίνακα NxK με τους γείτονες κάθε αντικειμένου σε αύξουσα σειρά απόστασης.

# Recall

Δέχεται δύο K-NN γράφους όπου ο πρώτος αποτελεί την πραγματική λύση και ο δεύτερος μια προσέγγιση και υπολογίζει το ποσοστό του recall. Ο πραγματικός γράφος λαμβάνεται από ένα αρχείο κειμένου. Σε περίπτωση που αυτό το αρχείο δεν υπάρχει, υπολογίζεται η πραγματική λύση με την χρήση του brute force και δημιουργείται το αρχείο.

# Readme

Παρέχουμε δύο συναρτήσεις για την δημιουργία dataset. Η πρώτη αφορά τα binary αρχεία του διαγωνισμού SIGMOD. Το δεύτερο αφορά ascii αρχεία από τον σύνδεσμο: https://www.cs.du.edu/~leut/MultiDimData.html (2D point data)

# Search

Παρέχονται δύο συναρτήσεις για την αναζήτηση των k-πλησιέστερων γειτόνων για ένα αντικείμενο. Η μια είναι σε θέση να λαμβάνει τον δυσδιάστατο γράφο (πίνακα), το dataset, και ένα αντικείμενο (τυχαίο ή και του ίδιου το γράφου) και να εκτελεί την αναζήτηση με τον τρόπο που περιγράφεται εδώ https://pynndescent.readthedocs.io/en/latest/how_pynndescent_works.html#Searching-using-a-nearest-neighbor-graph. Η δεύτερη συνάρτηση δέχεται ένα dataset και ένα αντικείμενο και βρίσκει τους k-πλησιέστερους γείτονες μέσω brute-force προσέγγισης. Τέλος, και οι δύο συναρτήσεις επιστρέφουν ένα πίνακα με τους k-πλησιέστερους γείτονες σε αύξουσα σειρά απόστασης.


# heap 

Το max-heap που έχει υλοποιηθεί αποθηκεύει το index του αντικείμενου στο dataset και την τιμή της μετρικής. Κριτήριο για αλλαγές στο heap αποτελεί η τιμή της μετρικής. Κατά συνέπεια, στην ρίζα του heap θα βρίσκεται ο γείτονας με την μεγαλύτερη τιμή της μετρικής. Παράλληλα, γίνεται χρήση ενός avl δένδρου που αποθηκεύει τα indexes των αντικειμένων που βρίσκονται στο heap κάθε στιγμή. Αυτό γίνεται, ώστε να επιτυγχάνονται γρήγορες αναζητήσεις αντικειμένων. Καθώς ενημερώνεται το heap, ενημερώνεται παράλληλα και το δένδρο. 


