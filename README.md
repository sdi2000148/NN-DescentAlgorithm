# Project-1
NN-descent algorithm in C

# Ηλίας Κωνσταντινίδης 1115202000109
Ασχολήθηκε με: List, Avl, Dataset

# Κωνσταντίνος Μυρτολλάρη 1115202000148
Ασχολήθηκε με: Heap, Search

# Άγγελος Γκουνέλας 1115202000038
Ασχολήθηκε με: Evaluation, ReadData, Tests, NN update

# Team
Ασχολήθηκε με: NN descent, NN descent local join, NN graph initialization, Brute force


Μεταγλώττιση των πηγαίων και εκτέλεση των tests γίνεται στον φάκελο Tests με τους εξής τρόπους:

-make

-make run

-make clean

-make valgrind


Το main.c σε αυτό το παραδοτέο δεν χρησιμοποιείται με κάποιον τρόπο. Ο φάκελος Include περιέχει τα header files και ο φάκελος Tests τα πηγαία αρχεία των tests. Οι υπόλοιποι φάκελοι περιέχουν τα πηγαία που υλοποιούν διάφορες δομές και συναρτήσεις χρήσιμες για την εργασία.

# Dataset

Το dataset περιγράφεται από ένα πλήθος αντικειμένων και διαστάσεων που είναι ίσες με το πλήθος των χαρακτηριστικών(features) του κάθε αντικειμένου. Τα χαρακτηριστικά είναι δείκτες σε δεδομένα και αρχικοποιούνται με NULL. Υπεύθυνος για την φόρτωση του dataset είναι ο χρήστης της βιβλιοθήκης. Η βιβλιοθήκη παρέχει την δυνατότητα για δεικτοδότηση και ενημέρωση των χαρακτηριστικών στα αντικείμενα του dataset. Η μετρική δημιουργείται επίσης από τον χρήστη της βιβλιοθήκης και πρέπει να λειτουργεί  σωστά, δεδομένου ότι αυτή δέχεται ως παράμετρους δείκτες γενικής χρήσης(να χρησιμοποιηθεί κατάλληλο casting). Η βιβλιοθήκη, τέλος δεν είναι υπεύθυνη για την αποδέσμευση της μνήμης των χαρακτηριστικών. 

# NNG initialization

Τυχαία αρχικοποίηση του γράφου αναθέτοντας K τυχαίους γείτονες για κάθε αντικείμενο. Συγκεκριμένα, για κάθε αντικείμενο, για κάθε τυχαία επιλογή γείτονα γίνεται ενημέρωση του heap τόσο του ενός όσο και του άλλου αντικειμένου, μιας και υπολογίζεται η μετρική μεταξύ των αντικειμένων. Αυτό μας επιτρέπει να εκμεταλλευόμαστε τους υπολογισμούς των μετρικών όσο το δυνατόν περισσότερο γίνεται.

# Brute force

Υπολογισμός του K-NN γράφου με την μέθοδο brute force και αποθήκευσή του σε έναν δισδιάστατο πίνακα NxK, ο οποίος και επιστρέφεται.

# NN-Descent

Δημιουργήσαμε δύο υλοποιήσεις του αλγορίθμου NN-Descent: την κλασσική υλοποίηση και την υλοποίηση με το local join. Η μόνη επιπλέον βελτιστοποίηση αφορά την χρήση ενός AVL δέντρου για κάθε αντικείμενο που αποθηκεύει τα αντικείμενα με τα οποία έχει συγκριθεί στο παρελθόν, ώστε να αποφεύγεται ο επαναϋπολογισμός της μετρικης για κάθε ζεύγος. Με λίγα λόγια, κάθε ζεύγος συγκρίνεται το πολύ μια φορά αφού η απόσταση τους αποθηκεύεται σε ένα από τα δύο AVL δέντρα. Η εύρεση των γειτόνων των αντικειμένων σε κάθε επανάληψη γίνεται με την ένωση των απευθείας γειτόνων(που βρίσκονται στο heap) και των αντιστρόφων γειτόνων(που βρίσκονται σε ένα ξεχωριστό AVL δέντρο), αποθηκεύοντας την σε μια λίστα. Έπειτα, γίνεται η σύγκριση όλων των γειτόνων του αντικειμένου μεταξύ τούς, ανάλογα με το αν αυτοί βρίσκονται στα AVL δέντρα του γείτονα με τον οποίο πρόκειται να συγκριθούν. Αν σε μια επιλογή δύο γειτόνων, ένας γείτονας βρίσκεται στο AVL δέντρο του άλλου, τότε ο υπολογισμός της απόστασης αποφεύγεται και ο αλγόριθμος συνεχίζει.

Για την αποθήκευση των K κοντινότερων γειτόνων καθώς ο αλγόριθμος εκτελείται, γίνεται χρήση ενός max heap μεγίστου μεγέθους K. Σε κάθε ενημέρωση του heap, γίνεται και ταυτόχρονη ενημέρωση του AVL δέντρου που βρίσκονται οι αντίστροφοι γείτονες του αντικειμένου. Επίσης, υπολογίζεται το scan-rate του αλγορίθμου σύμφωνα με το paper. Τέλος, η συνάρτηση επιστρέφει έναν δισδιάστατο πίνακα NxK με τους γείτονες κάθε αντικειμένου σε αύξουσα σειρά απόστασης.

# Recall

Δέχεται δύο K-NN γράφους όπου ο πρώτος αποτελεί την πραγματική λύση και ο δεύτερος μια προσέγγιση και υπολογίζει το ποσοστό του recall. Ο πραγματικός γράφος λαμβάνεται από ένα αρχείο κειμένου. Σε περίπτωση που αυτό το αρχείο δεν υπάρχει, υπολογίζεται η πραγματική λύση με την χρήση του brute force και δημιουργείται το αρχείο.

# Readme

Παρέχουμε δύο συναρτήσεις για την δημιουργία dataset. Η πρώτη αφορά τα binary αρχεία του διαγωνισμού SIGMOD. Το δεύτερο αφορά ascii αρχεία από τον σύνδεσμο: https://www.cs.du.edu/~leut/MultiDimData.html (2D point data)

# Search

Παρέχονται δύο συναρτήσεις για την αναζήτηση των k-πλησιέστερων γειτόνων για ένα αντικείμενο. Η μια είναι σε θέση να λαμβάνει τον δισδιάστατο πίνακα (γράφο), το dataset, και ένα αντικείμενο (τυχαίο ή και του ίδιου το γράφου) και να εκτελεί την αναζήτηση με τον τρόπο που περιγράφεται εδώ https://pynndescent.readthedocs.io/en/latest/how_pynndescent_works.html#Searching-using-a-nearest-neighbor-graph. Η δεύτερη συνάρτηση δέχεται ένα dataset και ένα αντικείμενο και βρίσκει τους k-πλησιέστερους γείτονες μέσω brute-force προσέγγισης. Τέλος, και οι δύο συναρτήσεις επιστρέφουν ένα πίνακα με τους k-πλησιέστερους γείτονες σε αύξουσα σειρά απόστασης.


# heap 

Το max-heap που έχει υλοποιηθεί αποθηκεύει το index του αντικείμενου στο dataset και την τιμή της μετρικής. Κριτήριο για αλλαγές στο heap αποτελεί η τιμή της μετρικής. Κατά συνέπεια, στην ρίζα του heap θα βρίσκεται ο γείτονας με την μεγαλύτερη τιμή της μετρικής. Παράλληλα, γίνεται χρήση ενός avl δένδρου που αποθηκεύει τα indexes των αντικειμένων που βρίσκονται στο heap κάθε στιγμή. Αυτό γίνεται, ώστε να επιτυγχάνονται γρήγορες αναζητήσεις αντικειμένων. Καθώς ενημερώνεται το heap, ενημερώνεται παράλληλα και το δένδρο. 

# Conclusion 

Στον φάκελο Media βρίσκονται τα αποτελέσματα της εκτέλεσης ορισμένων dataset του διαγωνισμού και των RectNode datasets(datasets από doubles με 4 διαστάσεις). Ως μετρική χρησιμοποιήθηκε η ευκλείδεια απόσταση. Σύμφωνα με αυτά τα αποτελέσματα, παρατηρούμε ότι ο αλγόριθμος είναι πιο αποδοτικός από τον brute force μόνο στις περιπτώσεις όπου το dataset έχει πολλά αντικείμενα και το k και οι διαστάσεις είναι σχετικά μικρές. Η απόδοση του αλγορίθμου επηρεάζεται αρνητικά σε μεγάλο βαθμό όσο αυξάνονται οι διαστάσεις του dataset(πιθανόν λόγω του φαινομένου hubness) και το k(πιθανόν λόγω της αύξησης του μεγέθους των heaps, των λιστών και των AVL δέντρων). Σημαντικό επίσης είναι το γεγονός ότι δεν καταφέραμε να τρέξει ο αλγόριθμος για το dataset RectNode με 50k αντικείμενα, παρά τις προσπάθειές μας να ελαχιστοποιήσουμε τα μεγέθη των δομών που χρησιμοποιούμε.


# Project-2

Εκτέλεση scripts:

-python run_nn.py

-python run_brute.py

# Brute force

Υπολογισμός της brute force λύσης υπολογίζοντας την μετρική κάθε ζεύγους μόνο μια φόρα. 

Το max-heap για κάθε στοιχείο αποθηκεύει πλέον και ένα flag αρχικοποιημένο σε 1. Παρέχεται και συνάρτηση που θέτει το flag σε μηδέν για κάποιο στοιχε
ο To flag προστέθηκε για την υποστήριξη της υλοποίησης του incremental searching.





# NN-Descent 

Υλοποίηση του increamental search και early termination. Αυτά, υλοποιήθηκαν ακολουθώντας την εκφώνηση του δεύτερου παραδοτέου. Το sampling υλοποιήθηκε με βάση τα papers: [1], [2]. Συγκεκριμένα, θεωρούμε ως sampled k το γινόμενο sampling percentage * k. Σε κάθε επανάληψη, για κάθε κόμβο, δημιουργούνται δύο heaps: το old μεγέθους k + sampled k και το new μεγέθους 2*sampled k, τα οποία αφορούν τόσο τους άμεσους όσο και τους αντίσττροφους γείτονες. Τα heaps έχουν τα εξής χαρακτηριστικά:
-Είναι σταθερού μεγέθους, οπότε αποθηκεύουν πλήθος στοιχείων που που προκύπτει από το ποσοστό sampling
-Ένα στοιχείο εισέρχεται ή όχι στο heap, με βάση την τιμή του που είναι ένα τυχαίο βάρος
Τα στοιχεία γίνονται sampled με βάση ένα flag το οποίο καθορίζει εαν βρισκεται σε κατάσταση new ή old. Το local join γίνεται με παρόμοιο τρόπο όπως στο πρώτο παραδοτέο.

# Observations

Η τεχνική του sampling και του early termination βελτίωσαν αισθητά την απόδοση του αλγορίθμου για μεγάλα datasets. Συγκεκριμένα, για dataset 50000 στοιχείων, ο brute force δημιούργησε τον k-nn γράφο σε χρόνο 1.812222e+03, ενώ ο nn descent με sampling 0.2 σε χρόνο 7.123332e+02. Αναμενόμενα, όσο μικρότερο το sampling τόσο μικρότερη και η ακρίβεια.  












[1] https://doi.org/10.1145/1963405.1963487
[2] https://doi.org/10.48550/arXiv.2112.06630 
